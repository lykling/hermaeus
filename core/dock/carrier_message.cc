// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file carrier_message.cpp
 * This source file contains the definition of the described types in the IDL
 * file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "carrier_message.h"

#include <fastcdr/Cdr.h>
#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

namespace hermaeus {
namespace core {

CarrierMessage::CarrierMessage() {
  // m_timestamp com.eprosima.idl.parser.typecode.PrimitiveTypeCode@5ae63ade
  m_timestamp = 0;
  // m_seq com.eprosima.idl.parser.typecode.PrimitiveTypeCode@610694f1
  m_seq = 0;
  // m_data com.eprosima.idl.parser.typecode.StringTypeCode@43814d18
  m_data = "";
  // m_datatype com.eprosima.idl.parser.typecode.StringTypeCode@5c5a1b69
  m_datatype = "";
}

CarrierMessage::~CarrierMessage() {}

CarrierMessage::CarrierMessage(const CarrierMessage& x) {
  m_timestamp = x.m_timestamp;
  m_seq = x.m_seq;
  m_data = x.m_data;
  m_datatype = x.m_datatype;
}

CarrierMessage::CarrierMessage(CarrierMessage&& x) {
  m_timestamp = x.m_timestamp;
  m_seq = x.m_seq;
  m_data = std::move(x.m_data);
  m_datatype = std::move(x.m_datatype);
}

CarrierMessage& CarrierMessage::operator=(const CarrierMessage& x) {
  m_timestamp = x.m_timestamp;
  m_seq = x.m_seq;
  m_data = x.m_data;
  m_datatype = x.m_datatype;

  return *this;
}

CarrierMessage& CarrierMessage::operator=(CarrierMessage&& x) {
  m_timestamp = x.m_timestamp;
  m_seq = x.m_seq;
  m_data = std::move(x.m_data);
  m_datatype = std::move(x.m_datatype);

  return *this;
}

size_t CarrierMessage::getMaxCdrSerializedSize(size_t current_alignment) {
  size_t initial_alignment = current_alignment;

  current_alignment +=
      4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

  current_alignment +=
      4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

  current_alignment +=
      4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

  current_alignment +=
      4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

  return current_alignment - initial_alignment;
}

size_t CarrierMessage::getCdrSerializedSize(const CarrierMessage& data,
                                            size_t current_alignment) {
  (void)data;
  size_t initial_alignment = current_alignment;

  current_alignment +=
      4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

  current_alignment +=
      4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

  current_alignment += 4 +
                       eprosima::fastcdr::Cdr::alignment(current_alignment, 4) +
                       data.data().size() + 1;

  current_alignment += 4 +
                       eprosima::fastcdr::Cdr::alignment(current_alignment, 4) +
                       data.datatype().size() + 1;

  return current_alignment - initial_alignment;
}

void CarrierMessage::serialize(eprosima::fastcdr::Cdr& scdr) const {
  scdr << m_timestamp;
  scdr << m_seq;
  scdr << m_data;
  scdr << m_datatype;
}

void CarrierMessage::deserialize(eprosima::fastcdr::Cdr& dcdr) {
  dcdr >> m_timestamp;
  dcdr >> m_seq;
  dcdr >> m_data;
  dcdr >> m_datatype;
}

/*!
 * @brief This function sets a value in member timestamp
 * @param _timestamp New value for member timestamp
 */
void CarrierMessage::timestamp(int32_t _timestamp) { m_timestamp = _timestamp; }

/*!
 * @brief This function returns the value of member timestamp
 * @return Value of member timestamp
 */
int32_t CarrierMessage::timestamp() const { return m_timestamp; }

/*!
 * @brief This function returns a reference to member timestamp
 * @return Reference to member timestamp
 */
int32_t& CarrierMessage::timestamp() { return m_timestamp; }

/*!
 * @brief This function sets a value in member seq
 * @param _seq New value for member seq
 */
void CarrierMessage::seq(int32_t _seq) { m_seq = _seq; }

/*!
 * @brief This function returns the value of member seq
 * @return Value of member seq
 */
int32_t CarrierMessage::seq() const { return m_seq; }

/*!
 * @brief This function returns a reference to member seq
 * @return Reference to member seq
 */
int32_t& CarrierMessage::seq() { return m_seq; }

/*!
 * @brief This function copies the value in member data
 * @param _data New value to be copied in member data
 */
void CarrierMessage::data(const std::string& _data) { m_data = _data; }

/*!
 * @brief This function moves the value in member data
 * @param _data New value to be moved in member data
 */
void CarrierMessage::data(std::string&& _data) { m_data = std::move(_data); }

/*!
 * @brief This function returns a constant reference to member data
 * @return Constant reference to member data
 */
const std::string& CarrierMessage::data() const { return m_data; }

/*!
 * @brief This function returns a reference to member data
 * @return Reference to member data
 */
std::string& CarrierMessage::data() { return m_data; }
/*!
 * @brief This function copies the value in member datatype
 * @param _datatype New value to be copied in member datatype
 */
void CarrierMessage::datatype(const std::string& _datatype) {
  m_datatype = _datatype;
}

/*!
 * @brief This function moves the value in member datatype
 * @param _datatype New value to be moved in member datatype
 */
void CarrierMessage::datatype(std::string&& _datatype) {
  m_datatype = std::move(_datatype);
}

/*!
 * @brief This function returns a constant reference to member datatype
 * @return Constant reference to member datatype
 */
const std::string& CarrierMessage::datatype() const { return m_datatype; }

/*!
 * @brief This function returns a reference to member datatype
 * @return Reference to member datatype
 */
std::string& CarrierMessage::datatype() { return m_datatype; }

size_t CarrierMessage::getKeyMaxCdrSerializedSize(size_t current_alignment) {
  size_t current_align = current_alignment;

  return current_align;
}

bool CarrierMessage::isKeyDefined() { return false; }

void CarrierMessage::serializeKey(eprosima::fastcdr::Cdr& scdr) const {
  (void)scdr;
}

}  // namespace core
}  // namespace hermaeus
